using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator.Generator;

[Generator]
public class QEventInterfaceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // 初始化
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // 获取当前语法树
        var syntaxTrees = context.Compilation.SyntaxTrees;
        List<string> classNameList = new List<string>();

        foreach (var tree in syntaxTrees)
        {
            // 获取语法树的根节点
            var root = tree.GetRoot();

            // 获取当前语法树中的所有命名空间节点
            var namespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>();

            if (namespaces.All(ns => !Definition.TargetNameSpaces.Contains(ns.Name.ToString())))
            {
                continue;
            }

            var interfaces = GetMatchInterfaces(root);

            foreach (var interfaceNode in interfaces)
            {
                var interfaceName = interfaceNode.Identifier.ToString();
                var fullName = GetInterfaceFullName(interfaceNode, interfaceName);
                var eventClassName = $"{interfaceName}_Event";
                var eventClassCode = GenerateEventClass(interfaceName, eventClassName, interfaceNode);
                context.AddSource($"{eventClassName}.g.cs", eventClassCode);

                // 生成实现类
                var implementationClassCode = GenerateImplementationClass(fullName, interfaceName, interfaceNode,context);
                context.AddSource($"{interfaceName}_Gen.g.cs", implementationClassCode);
                classNameList.Add($"{interfaceName}_Gen");
            }
        }

        if (classNameList.Count > 0)
        {
            string uniqueFileName = $"GameEventLauncher.g.cs";
            context.AddSource(uniqueFileName, GenerateGameEventHelper(classNameList));
        }
    }

    /// <summary>
    /// 生成事件中心启动器脚本
    /// </summary>
    /// <param name="classNameList"></param>
    /// <returns></returns>
    private string GenerateGameEventHelper(List<string> classNameList)
    {
        var sb = new StringBuilder();
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// \tThis code was generated by the source generator.");
        sb.AppendLine("// \tChanges to this file may cause incorrect behavior.");
        sb.AppendLine("// \twill be lost if the code is regenerated.");
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine();
        foreach (var usingNameSpace in Definition.UsingNameSpace)
        {
            sb.AppendLine($"using {usingNameSpace};");
        }
        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.NameSpace}");
        {
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic static class GameEventLauncher");
            {
                sb.AppendLine("\t{");
                sb.AppendLine($"\t\tpublic static void Init()");
                {
                    sb.AppendLine("\t\t{");
                    foreach (var className in classNameList)
                    {
                        sb.AppendLine($"\t\t\tvar m_{className} = new {className}(GameEvent.EventMgr.GetDispatcher());");
                    }
                    sb.AppendLine("\t\t}");
                }
                sb.AppendLine("\t}");
            }
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// 生成接口实现类
    /// </summary>
    /// <param name="fullName"></param>
    /// <param name="interfaceName"></param>
    /// <param name="interfaceNode"></param>
    /// <param name="context"></param>
    /// <returns></returns>
    private string GenerateImplementationClass(string fullName, string interfaceName, InterfaceDeclarationSyntax interfaceNode, GeneratorExecutionContext context)
    {
        // 获取接口节点语法模型
        var semanticModel = context.Compilation.GetSemanticModel(interfaceNode.SyntaxTree);
        var sb = new StringBuilder();
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// \tThis code was generated by the source generator.");
        sb.AppendLine("// \tChanges to this file may cause incorrect behavior.");
        sb.AppendLine("// \twill be lost if the code is regenerated.");
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine();
        foreach (var usingNameSpace in Definition.UsingNameSpace)
        {
            sb.AppendLine($"using {usingNameSpace};");
        }
        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.NameSpace}");
        {
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic partial class {interfaceName}_Gen : {interfaceName}");
            {
                sb.AppendLine("\t{");
                sb.AppendLine("\t\tprivate EventDispatcher m_dispatcher;");
                sb.AppendLine($"\t\tpublic {interfaceName}_Gen(EventDispatcher dispatcher)");
                {
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tm_dispatcher = dispatcher;");
                    sb.AppendLine($"\t\t\tGameEvent.EventMgr.RegWrapInterface(\"{fullName}\", this);");
                    sb.AppendLine("\t\t}");
                }

                foreach (var method in interfaceNode.Members.OfType<MethodDeclarationSyntax>())
                {
                    var methodName = method.Identifier.ToString();
                    var parameters = GenerateParameters(method, semanticModel);

                    sb.AppendLine($"\t\tpublic void {methodName}({parameters})");
                    {
                        sb.AppendLine("\t\t{");
                        if (method.ParameterList.Parameters.Count > 0)
                        {
                            var paramNames = string.Join(", ", method.ParameterList.Parameters.Select(p => p.Identifier.ToString()));
                            sb.AppendLine($"\t\t\tm_dispatcher.Send({interfaceName}_Event.{methodName}, {paramNames});");
                        }
                        else
                        {
                            sb.AppendLine($"\t\t\tm_dispatcher.Send({interfaceName}_Event.{methodName});");
                        }
                        sb.AppendLine("\t\t}");
                    }
                }

                sb.AppendLine("\t}");
            }
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private string GenerateParameters(MethodDeclarationSyntax method, SemanticModel semanticModel)
    {
        return string.Join(", ", method.ParameterList.Parameters.Select(p =>
        {
            var typeSymbol = semanticModel.GetTypeInfo(p.Type).Type;
            return typeSymbol != null
                ? $"{typeSymbol.ToDisplayString()} {p.Identifier}"
                : $"{p.Type} {p.Identifier}";
        }));
    }

    /// <summary>
    /// 生成接口字典key类
    /// </summary>
    /// <param name="interfaceName"></param>
    /// <param name="eventClassName"></param>
    /// <param name="interfaceNode"></param>
    /// <returns></returns>
    private string GenerateEventClass(string interfaceName, string eventClassName, InterfaceDeclarationSyntax interfaceNode)
    {
        // 获取接口在的所有方法
        var methods = interfaceNode.Members.OfType<MethodDeclarationSyntax>();
        var sb = new StringBuilder();
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// \tThis code was generated by the source generator.");
        sb.AppendLine("// \tChanges to this file may cause incorrect behavior.");
        sb.AppendLine("// \twill be lost if the code is regenerated.");
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("//----------------------------------------------------------");

        sb.AppendLine();
        foreach (var usingNameSpace in Definition.UsingNameSpace)
        {
            sb.AppendLine($"using {usingNameSpace};");
        }
        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.NameSpace}");
        {
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic partial class {eventClassName}");
            {
                sb.AppendLine("\t{");
                foreach (var method in methods)
                {
                    var methodName = method.Identifier.ToString();
                    var parameters = string.Join(", ", method.ParameterList.Parameters.Select(p => $"{p.Type} {p.Identifier}"));
                    sb.AppendLine($"\t\tpublic static readonly int {methodName} = {Definition.StringToHash}(\"{eventClassName}.{methodName}\");");
                }
                sb.AppendLine("\t}");
            }
            sb.AppendLine("}");
        }
        return sb.ToString();
    }

    /// <summary>
    /// 获取接口的FullName 带命名空间
    /// </summary>
    /// <param name="interfaceNode"></param>
    /// <param name="interfaceName"></param>
    /// <returns></returns>
    private string GetInterfaceFullName(InterfaceDeclarationSyntax interfaceNode, string interfaceName)
    {
        var fullName = interfaceNode.SyntaxTree.GetRoot()
            .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
            .Select(nameSpace => nameSpace.Name.ToString())
            .Concat([interfaceName])
            .Aggregate((a, b) => $"{a}.{b}");
        return fullName;
    }

    /// <summary>
    /// 获取匹配的接口声明语法
    /// </summary>
    /// <param name="root"></param>
    /// <returns></returns>
    private IEnumerable<InterfaceDeclarationSyntax> GetMatchInterfaces(SyntaxNode root)
    {
        return root.DescendantNodes().OfType<InterfaceDeclarationSyntax>()
            .Where(i => i.AttributeLists.Count > 0
                        && i.AttributeLists.Any(attrList => attrList.Attributes
                            .Any(attr => attr.Name.ToString().Equals(Definition.AttributeName))));
    }
}